package main

import (
    "bufio"
    "fmt"
    "os"
    "os/exec"
    "regexp"
    "strings"
)

func main() {
    // Open the tfvars file
    file, err := os.Open("terraform.tfvars")
    if err != nil {
        fmt.Println("Error opening terraform.tfvars:", err)
        return
    }
    defer file.Close()

    // Read the file line by line
    scanner := bufio.NewScanner(file)
    lines := []string{}
    variables := make(map[string]string)
    vmVariables := make(map[string]map[string]string)
    var currentVM string
    inVMs := false

    // Regular expressions to match variable assignments and VM definitions
    varAssignmentRegex := regexp.MustCompile(`^\s*([a-zA-Z0-9_]+)\s*=\s*(.*)`)
    vmStartRegex := regexp.MustCompile(`^\s*"([^"]+)"\s*=\s*\{`)
    vmEndRegex := regexp.MustCompile(`^\s*\},?\s*$`)
    vmAttrRegex := regexp.MustCompile(`^\s*([a-zA-Z0-9_]+)\s*=\s*(.*)`)

    for scanner.Scan() {
        line := scanner.Text()
        lines = append(lines, line)

        if inVMs {
            if vmEndRegex.MatchString(line) {
                inVMs = false
                currentVM = ""
                continue
            }
            if vmAttrRegex.MatchString(line) {
                matches := vmAttrRegex.FindStringSubmatch(line)
                attrName := matches[1]
                attrValue := matches[2]
                vmVariables[currentVM][attrName] = attrValue
            }
            continue
        }

        if strings.TrimSpace(line) == "vms = {" {
            inVMs = true
            continue
        }

        if inVMs {
            if vmStartRegex.MatchString(line) {
                matches := vmStartRegex.FindStringSubmatch(line)
                currentVM = matches[1]
                vmVariables[currentVM] = make(map[string]string)
                continue
            }
        } else if varAssignmentRegex.MatchString(line) {
            matches := varAssignmentRegex.FindStringSubmatch(line)
            varName := matches[1]
            varValue := matches[2]
            variables[varName] = varValue
        }
    }

    if err := scanner.Err(); err != nil {
        fmt.Println("Error reading terraform.tfvars:", err)
        return
    }

    // Prompt the user to modify variables
    reader := bufio.NewReader(os.Stdin)
    for varName, varValue := range variables {
        fmt.Printf("Current value for %s: %s\n", varName, varValue)
        fmt.Printf("Enter new value for %s (leave blank to keep current value): ", varName)
        input, _ := reader.ReadString('\n')
        input = strings.TrimSpace(input)
        if input != "" {
            variables[varName] = input
        }
    }

    // Prompt the user to modify VMs
    for vmName, attrs := range vmVariables {
        fmt.Printf("\nConfiguring %s:\n", vmName)
        for attrName, attrValue := range attrs {
            fmt.Printf("Current value for %s: %s\n", attrName, attrValue)
            fmt.Printf("Enter new value for %s (leave blank to keep current value): ", attrName)
            input, _ := reader.ReadString('\n')
            input = strings.TrimSpace(input)
            if input != "" {
                vmVariables[vmName][attrName] = input
            }
        }
    }

    // Now, write back the modified variables to the file
    fileOut, err := os.Create("terraform.tfvars")
    if err != nil {
        fmt.Println("Error creating terraform.tfvars:", err)
        return
    }
    defer fileOut.Close()

    inVMs = false
    currentVM = ""
    for _, line := range lines {
        if inVMs {
            if vmEndRegex.MatchString(line) {
                inVMs = false
                fmt.Fprintln(fileOut, "  },")
                continue
            }
            if vmStartRegex.MatchString(line) {
                // Write the VM start line
                matches := vmStartRegex.FindStringSubmatch(line)
                vmName := matches[1]
                currentVM = vmName
                fmt.Fprintf(fileOut, "  \"%s\" = {\n", vmName)
                // Write the modified attributes
                attrs := vmVariables[vmName]
                for attrName, attrValue := range attrs {
                    fmt.Fprintf(fileOut, "    %s = %s\n", attrName, attrValue)
                }
                continue
            }
            continue
        }

        if strings.TrimSpace(line) == "vms = {" {
            inVMs = true
            fmt.Fprintln(fileOut, "vms = {")
            continue
        }

        if varAssignmentRegex.MatchString(line) {
            matches := varAssignmentRegex.FindStringSubmatch(line)
            varName := matches[1]
            if newValue, ok := variables[varName]; ok {
                fmt.Fprintf(fileOut, "%s = %s\n", varName, newValue)
            } else {
                fmt.Fprintln(fileOut, line)
            }
        } else {
            fmt.Fprintln(fileOut, line)
        }
    }

    // Now run terraform commands
    cmds := []string{"init", "plan", "apply"}
    for _, cmd := range cmds {
        fmt.Printf("\nRunning 'terraform %s'...\n", cmd)
        terraformCmd := exec.Command("terraform", cmd)
        terraformCmd.Stdout = os.Stdout
        terraformCmd.Stderr = os.Stderr
        terraformCmd.Stdin = os.Stdin
        err := terraformCmd.Run()
        if err != nil {
            fmt.Printf("Error running 'terraform %s': %s\n", cmd, err)
  
